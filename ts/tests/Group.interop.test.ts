/**
 * Group interop test - generates test vectors for Rust and verifies Rust-generated vectors
 */
import { describe, it, expect, beforeAll } from "vitest";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import {
  createGroupData,
  buildGroupMetadataContent,
  parseGroupMetadata,
  type GroupData,
  type GroupMetadata,
} from "../src/Group";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ALICE = "aaaa".repeat(16);
const BOB = "bbbb".repeat(16);
const CAROL = "cccc".repeat(16);

interface GroupVectors {
  description: string;
  create_group: {
    input: { name: string; creator: string; members: string[] };
    output: GroupData;
  };
  metadata_with_secret: string;
  metadata_without_secret: string;
  parse_vectors: Array<{
    description: string;
    input: string;
    expected: GroupMetadata | null;
  }>;
}

describe("Group Interop Vector Generation", () => {
  let vectors: GroupVectors;

  beforeAll(() => {
    // Create a group with deterministic data (override random fields)
    const group = createGroupData("Interop Test Group", ALICE, [BOB, CAROL]);
    // Override random fields for determinism
    group.id = "interop-test-group-id";
    group.createdAt = 1700000000000;
    group.secret = "s".repeat(64);

    const metadataWithSecret = buildGroupMetadataContent(group);
    const metadataWithoutSecret = buildGroupMetadataContent(group, {
      excludeSecret: true,
    });

    const parseVectors: GroupVectors["parse_vectors"] = [
      {
        description: "valid metadata with all fields",
        input: JSON.stringify({
          id: "g1",
          name: "Test",
          description: "A test group",
          picture: "https://example.com/pic.jpg",
          members: [ALICE, BOB],
          admins: [ALICE],
          secret: "x".repeat(64),
        }),
        expected: {
          id: "g1",
          name: "Test",
          description: "A test group",
          picture: "https://example.com/pic.jpg",
          members: [ALICE, BOB],
          admins: [ALICE],
          secret: "x".repeat(64),
        },
      },
      {
        description: "valid metadata without optional fields",
        input: JSON.stringify({
          id: "g2",
          name: "Minimal",
          members: [ALICE],
          admins: [ALICE],
        }),
        expected: {
          id: "g2",
          name: "Minimal",
          members: [ALICE],
          admins: [ALICE],
        },
      },
      {
        description: "invalid - missing id",
        input: JSON.stringify({
          name: "Bad",
          members: [ALICE],
          admins: [ALICE],
        }),
        expected: null,
      },
      {
        description: "invalid - empty admins",
        input: JSON.stringify({
          id: "g3",
          name: "Bad",
          members: [ALICE],
          admins: [],
        }),
        expected: null,
      },
      {
        description: "invalid - not JSON",
        input: "not json",
        expected: null,
      },
    ];

    vectors = {
      description: "Group test vectors generated by TypeScript",
      create_group: {
        input: { name: "Interop Test Group", creator: ALICE, members: [BOB, CAROL] },
        output: group,
      },
      metadata_with_secret: metadataWithSecret,
      metadata_without_secret: metadataWithoutSecret,
      parse_vectors: parseVectors,
    };

    const outputPath = path.join(
      __dirname,
      "../../test-vectors/ts-group-vectors.json"
    );
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(vectors, null, 2));
    console.log(`Generated group test vectors at ${outputPath}`);
  });

  it("should generate valid group vectors", () => {
    expect(vectors.create_group.output.name).toBe("Interop Test Group");
    expect(vectors.create_group.output.members).toEqual([ALICE, BOB, CAROL]);
    expect(vectors.create_group.output.admins).toEqual([ALICE]);
  });

  it("TS can parse its own metadata content", () => {
    const parsed = parseGroupMetadata(vectors.metadata_with_secret);
    expect(parsed).not.toBeNull();
    expect(parsed!.id).toBe("interop-test-group-id");
    expect(parsed!.name).toBe("Interop Test Group");
    expect(parsed!.secret).toBe("s".repeat(64));
  });

  it("metadata without secret has no secret field", () => {
    const parsed = parseGroupMetadata(vectors.metadata_without_secret);
    expect(parsed).not.toBeNull();
    expect(parsed!.secret).toBeUndefined();
  });
});

describe("Rust-generated group vectors", () => {
  it("TypeScript can parse Rust group metadata", () => {
    const vectorPath = path.join(
      __dirname,
      "../../test-vectors/rust-group-vectors.json"
    );

    if (!fs.existsSync(vectorPath)) {
      console.log("Rust group vectors not found, skipping...");
      return;
    }

    const vectors: GroupVectors = JSON.parse(
      fs.readFileSync(vectorPath, "utf-8")
    );

    // Verify we can parse Rust's metadata output
    const parsedWithSecret = parseGroupMetadata(vectors.metadata_with_secret);
    expect(parsedWithSecret).not.toBeNull();
    expect(parsedWithSecret!.id).toBe(vectors.create_group.output.id);
    expect(parsedWithSecret!.name).toBe(vectors.create_group.output.name);
    expect(parsedWithSecret!.members).toEqual(
      vectors.create_group.output.members
    );
    expect(parsedWithSecret!.admins).toEqual(
      vectors.create_group.output.admins
    );

    const parsedWithoutSecret = parseGroupMetadata(
      vectors.metadata_without_secret
    );
    expect(parsedWithoutSecret).not.toBeNull();
    expect(parsedWithoutSecret!.secret).toBeUndefined();

    // Verify parse vectors
    for (const pv of vectors.parse_vectors) {
      const result = parseGroupMetadata(pv.input);
      if (pv.expected === null) {
        expect(result).toBeNull();
      } else {
        expect(result).not.toBeNull();
        expect(result!.id).toBe(pv.expected.id);
        expect(result!.name).toBe(pv.expected.name);
      }
    }

    console.log("Successfully verified Rust-generated group vectors");
  });
});
