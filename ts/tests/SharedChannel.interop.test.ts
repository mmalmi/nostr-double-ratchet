/**
 * SharedChannel interop test - generates test vectors for Rust and verifies Rust-generated vectors
 */
import { describe, it, expect, beforeAll } from "vitest";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import { hexToBytes, bytesToHex } from "@noble/hashes/utils";
import { getPublicKey } from "nostr-tools";
import { SharedChannel, SHARED_CHANNEL_KIND } from "../src/SharedChannel";
import { GROUP_INVITE_RUMOR_KIND } from "../src/Group";
import type { Rumor } from "../src/types";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface SharedChannelVectors {
  description: string;
  secret_hex: string;
  channel_pubkey: string;
  encrypted_event: {
    id: string;
    pubkey: string;
    created_at: number;
    kind: number;
    tags: string[][];
    content: string;
    sig: string;
  } | null;
  plaintext_rumor: Rumor;
  group_tagged_event: Rumor;
}

const SECRET_HEX =
  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

describe("SharedChannel Interop Vector Generation", () => {
  let vectors: SharedChannelVectors;

  beforeAll(() => {
    const secretBytes = hexToBytes(SECRET_HEX);
    const channel = new SharedChannel(secretBytes);

    const rumor: Rumor = {
      id: "interop-test-rumor",
      pubkey:
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
      created_at: 1700000000,
      kind: GROUP_INVITE_RUMOR_KIND,
      tags: [],
      content: JSON.stringify({
        inviteUrl: "https://iris.to#interop",
        groupId: "interop-group",
      }),
    };

    const event = channel.createEvent(rumor);

    const groupTaggedEvent: Rumor = {
      id: "group-msg-id",
      pubkey:
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
      created_at: 1700000000,
      kind: 14,
      tags: [
        ["l", "test-group-id"],
        ["ms", "1700000000000"],
      ],
      content: "Hello from TypeScript group!",
    };

    vectors = {
      description: "SharedChannel test vectors generated by TypeScript",
      secret_hex: SECRET_HEX,
      channel_pubkey: channel.publicKey,
      encrypted_event: {
        id: event.id,
        pubkey: event.pubkey,
        created_at: event.created_at,
        kind: event.kind,
        tags: event.tags,
        content: event.content,
        sig: event.sig,
      },
      plaintext_rumor: rumor,
      group_tagged_event: groupTaggedEvent,
    };

    const outputPath = path.join(
      __dirname,
      "../../test-vectors/ts-shared-channel-vectors.json"
    );
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(vectors, null, 2));
    console.log(`Generated SharedChannel test vectors at ${outputPath}`);
  });

  it("should derive correct pubkey from secret", () => {
    const expectedPubkey = getPublicKey(hexToBytes(SECRET_HEX));
    expect(vectors.channel_pubkey).toBe(expectedPubkey);
  });

  it("should generate valid encrypted event", () => {
    expect(vectors.encrypted_event).not.toBeNull();
    expect(vectors.encrypted_event!.kind).toBe(SHARED_CHANNEL_KIND);
    expect(vectors.encrypted_event!.pubkey).toBe(vectors.channel_pubkey);
  });

  it("TS can decrypt its own encrypted event", () => {
    const secretBytes = hexToBytes(SECRET_HEX);
    const channel = new SharedChannel(secretBytes);
    const decrypted = channel.decryptEvent(vectors.encrypted_event as any);
    expect(decrypted.pubkey).toBe(vectors.plaintext_rumor.pubkey);
    expect(decrypted.kind).toBe(vectors.plaintext_rumor.kind);
    expect(decrypted.content).toBe(vectors.plaintext_rumor.content);
  });

  it("group tagged event has correct tags", () => {
    const tags = vectors.group_tagged_event.tags;
    const lTag = tags.find((t) => t[0] === "l");
    expect(lTag).toBeDefined();
    expect(lTag![1]).toBe("test-group-id");

    const msTag = tags.find((t) => t[0] === "ms");
    expect(msTag).toBeDefined();
    expect(msTag![1]).toBe("1700000000000");
  });
});

describe("Rust-generated SharedChannel vectors", () => {
  it("TypeScript can decrypt Rust SharedChannel event", () => {
    const vectorPath = path.join(
      __dirname,
      "../../test-vectors/rust-shared-channel-vectors.json"
    );

    if (!fs.existsSync(vectorPath)) {
      console.log(
        "Rust SharedChannel vectors not found at",
        vectorPath,
        "skipping..."
      );
      console.log(
        'Run `cargo test -p nostr-double-ratchet --test shared_channel_interop` to generate them.'
      );
      return;
    }

    const vectors: SharedChannelVectors = JSON.parse(
      fs.readFileSync(vectorPath, "utf-8")
    );
    console.log("Loaded SharedChannel vectors:", vectors.description);

    // Verify same pubkey derivation
    const secretBytes = hexToBytes(vectors.secret_hex);
    const channel = new SharedChannel(secretBytes);
    expect(channel.publicKey).toBe(vectors.channel_pubkey);

    // Decrypt Rust-encrypted event
    if (vectors.encrypted_event) {
      expect(channel.isChannelEvent(vectors.encrypted_event as any)).toBe(true);

      const decrypted = channel.decryptEvent(vectors.encrypted_event as any);
      expect(decrypted.pubkey).toBe(vectors.plaintext_rumor.pubkey);
      expect(decrypted.kind).toBe(vectors.plaintext_rumor.kind);
    }

    // Verify group tagged event format
    const tags = vectors.group_tagged_event.tags;
    const lTag = tags.find((t: string[]) => t[0] === "l");
    expect(lTag).toBeDefined();

    const msTag = tags.find((t: string[]) => t[0] === "ms");
    expect(msTag).toBeDefined();

    console.log("Successfully verified Rust-generated SharedChannel vectors!");
  });
});
