/**
 * Interop test - generates test vectors and verifies they can be processed
 */
import { describe, it, expect, beforeAll, vi } from "vitest";
import { getPublicKey } from "nostr-tools";
import { hexToBytes, bytesToHex } from "@noble/hashes/utils";
import { Session } from "../src/Session";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Deterministic test keys (for reproducibility)
const ALICE_EPHEMERAL_SK = hexToBytes("1111111111111111111111111111111111111111111111111111111111111111");
const BOB_EPHEMERAL_SK = hexToBytes("2222222222222222222222222222222222222222222222222222222222222222");
const SHARED_SECRET = hexToBytes("3333333333333333333333333333333333333333333333333333333333333333");

// Mock nostr subscribe - we don't need actual subscriptions for vector generation
const mockSubscribe = () => () => {};

interface TestVector {
  description: string;
  alice_ephemeral_sk: string;
  alice_ephemeral_pk: string;
  bob_ephemeral_sk: string;
  bob_ephemeral_pk: string;
  shared_secret: string;
  messages: Array<{
    sender: "alice" | "bob";
    plaintext: string;
    encrypted_event: {
      id: string;
      pubkey: string;
      created_at: number;
      kind: number;
      tags: string[][];
      content: string;
      sig: string;
    };
  }>;
}

// Fixed timestamp for deterministic test vectors (2024-01-01 00:00:00 UTC)
const FIXED_TIMESTAMP = 1704067200000;

describe("Interop Test Vector Generation", () => {
  let vectors: TestVector;

  beforeAll(() => {
    // Mock Date.now() to return a fixed timestamp for deterministic vectors
    vi.spyOn(Date, "now").mockReturnValue(FIXED_TIMESTAMP);
    const aliceEphemeralPk = getPublicKey(ALICE_EPHEMERAL_SK);
    const bobEphemeralPk = getPublicKey(BOB_EPHEMERAL_SK);

    // Alice is initiator
    const alice = Session.init(
      mockSubscribe,
      bobEphemeralPk,
      ALICE_EPHEMERAL_SK,
      true,
      SHARED_SECRET,
      "alice"
    );

    // Bob is responder
    const bob = Session.init(
      mockSubscribe,
      aliceEphemeralPk,
      BOB_EPHEMERAL_SK,
      false,
      SHARED_SECRET,
      "bob"
    );

    const messages: TestVector["messages"] = [];

    // Message 1: Alice -> Bob
    const msg1 = alice.send("Hello from TypeScript!");
    messages.push({
      sender: "alice",
      plaintext: "Hello from TypeScript!",
      encrypted_event: {
        id: msg1.event.id,
        pubkey: msg1.event.pubkey,
        created_at: msg1.event.created_at,
        kind: msg1.event.kind,
        tags: msg1.event.tags,
        content: msg1.event.content,
        sig: msg1.event.sig,
      },
    });

    // Bob receives and decrypts (to advance his ratchet state)
    (bob as any).handleNostrEvent(msg1.event);

    // Message 2: Bob -> Alice
    const msg2 = bob.send("Hello back from TypeScript Bob!");
    messages.push({
      sender: "bob",
      plaintext: "Hello back from TypeScript Bob!",
      encrypted_event: {
        id: msg2.event.id,
        pubkey: msg2.event.pubkey,
        created_at: msg2.event.created_at,
        kind: msg2.event.kind,
        tags: msg2.event.tags,
        content: msg2.event.content,
        sig: msg2.event.sig,
      },
    });

    // Alice receives
    (alice as any).handleNostrEvent(msg2.event);

    // Message 3: Alice -> Bob (after ratchet)
    const msg3 = alice.send("Second message from Alice");
    messages.push({
      sender: "alice",
      plaintext: "Second message from Alice",
      encrypted_event: {
        id: msg3.event.id,
        pubkey: msg3.event.pubkey,
        created_at: msg3.event.created_at,
        kind: msg3.event.kind,
        tags: msg3.event.tags,
        content: msg3.event.content,
        sig: msg3.event.sig,
      },
    });

    vectors = {
      description: "Test vectors generated by TypeScript implementation",
      alice_ephemeral_sk: bytesToHex(ALICE_EPHEMERAL_SK),
      alice_ephemeral_pk: aliceEphemeralPk,
      bob_ephemeral_sk: bytesToHex(BOB_EPHEMERAL_SK),
      bob_ephemeral_pk: bobEphemeralPk,
      shared_secret: bytesToHex(SHARED_SECRET),
      messages,
    };

    // Write vectors to file only if it doesn't exist or REGENERATE_VECTORS is set
    const outputPath = path.join(__dirname, "../../test-vectors/ts-generated.json");
    const shouldRegenerate = process.env.REGENERATE_VECTORS === "true" || !fs.existsSync(outputPath);

    if (shouldRegenerate) {
      fs.mkdirSync(path.dirname(outputPath), { recursive: true });
      fs.writeFileSync(outputPath, JSON.stringify(vectors, null, 2));
      console.log(`Generated test vectors at ${outputPath}`);
    } else {
      console.log(`Test vectors already exist at ${outputPath} (set REGENERATE_VECTORS=true to regenerate)`);
    }
  });

  it("should generate valid test vectors", () => {
    expect(vectors.messages.length).toBe(3);
    expect(vectors.messages[0].sender).toBe("alice");
    expect(vectors.messages[1].sender).toBe("bob");
    expect(vectors.messages[2].sender).toBe("alice");
  });

  it("TypeScript can decrypt its own messages", () => {
    const aliceEphemeralPk = getPublicKey(ALICE_EPHEMERAL_SK);
    const bobEphemeralPk = getPublicKey(BOB_EPHEMERAL_SK);

    // Fresh sessions for direct message exchange (not using pre-generated vectors)
    const alice = Session.init(
      mockSubscribe,
      bobEphemeralPk,
      ALICE_EPHEMERAL_SK,
      true,
      SHARED_SECRET,
      "alice"
    );

    const bob = Session.init(
      mockSubscribe,
      aliceEphemeralPk,
      BOB_EPHEMERAL_SK,
      false,
      SHARED_SECRET,
      "bob"
    );

    const receivedMessages: string[] = [];

    // Bob subscribes to messages
    bob.onEvent((event) => {
      receivedMessages.push(event.content);
    });

    // Alice sends first message directly (not from vectors)
    const aliceMsg = alice.send("Hello from Alice!");
    (bob as any).handleNostrEvent(aliceMsg.event);
    expect(receivedMessages).toContain("Hello from Alice!");

    // Now Bob can send a reply
    const bobMsg = bob.send("Reply from Bob");

    // Alice subscribes
    alice.onEvent((event) => {
      receivedMessages.push(event.content);
    });

    (alice as any).handleNostrEvent(bobMsg.event);
    expect(receivedMessages).toContain("Reply from Bob");
  });
});

describe("Rust-generated vectors", () => {
  it("TypeScript can decrypt Rust-generated messages", () => {
    const vectorPath = path.join(__dirname, "../../test-vectors/rust-generated.json");

    if (!fs.existsSync(vectorPath)) {
      console.log("Rust vectors not found, skipping...");
      return;
    }

    const vectors: TestVector = JSON.parse(fs.readFileSync(vectorPath, "utf-8"));

    const _aliceEphemeralSk = hexToBytes(vectors.alice_ephemeral_sk);
    const bobEphemeralSk = hexToBytes(vectors.bob_ephemeral_sk);
    const sharedSecret = hexToBytes(vectors.shared_secret);

    // Create Bob session to receive Alice's messages
    const bob = Session.init(
      mockSubscribe,
      vectors.alice_ephemeral_pk,
      bobEphemeralSk,
      false,
      sharedSecret,
      "bob"
    );

    const receivedMessages: string[] = [];
    bob.onEvent((event) => {
      receivedMessages.push(event.content);
    });

    // Process Alice's message from Rust
    const aliceMsg = vectors.messages.find(m => m.sender === "alice");
    if (aliceMsg) {
      (bob as any).handleNostrEvent(aliceMsg.encrypted_event);
      expect(receivedMessages).toContain(aliceMsg.plaintext);
      console.log("Successfully decrypted Rust-generated message:", aliceMsg.plaintext);
    }
  });
});
