/**
 * OneToManyChannel + SenderKey interop test.
 *
 * - Generates TS vectors for Rust to verify (ts-one-to-many-vectors.json).
 * - Verifies Rust-generated vectors if present (rust-one-to-many-vectors.json).
 */
import { beforeAll, describe, expect, it } from "vitest";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import { bytesToHex, hexToBytes } from "@noble/hashes/utils";
import { getPublicKey } from "nostr-tools";

import { OneToManyChannel } from "../src/OneToManyChannel";
import { SenderKeyState } from "../src/SenderKey";
import type { NostrEvent } from "../src/types";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface OneToManyVectors {
  description: string;
  sender_secret_hex: string;
  sender_pubkey: string;
  key_id: number;
  chain_key_hex: string;
  iteration: number;
  created_at: number;
  messages: Array<{
    plaintext: string;
    outer_event: NostrEvent;
  }>;
}

const CREATED_AT = 1_700_000_000;
const KEY_ID = 123;
const CHAIN_KEY_BYTES = new Uint8Array(32).fill(7);
const SENDER_SECRET_HEX = "11".repeat(32);

describe("OneToMany Interop Vector Generation", () => {
  let vectors: OneToManyVectors;

  beforeAll(() => {
    const senderSk = hexToBytes(SENDER_SECRET_HEX);
    const senderPk = getPublicKey(senderSk);

    const channel = OneToManyChannel.default();
    const sender = new SenderKeyState(KEY_ID, CHAIN_KEY_BYTES, 0);

    const outer0 = channel.encryptToOuterEvent(
      senderSk,
      sender,
      JSON.stringify({ kind: 14, content: "Hello from TypeScript sender keys (0)" }),
      CREATED_AT
    );

    const outer1 = channel.encryptToOuterEvent(
      senderSk,
      sender,
      JSON.stringify({ kind: 14, content: "Hello from TypeScript sender keys (1)" }),
      CREATED_AT
    );

    vectors = {
      description: "OneToManyChannel test vectors generated by TypeScript",
      sender_secret_hex: SENDER_SECRET_HEX,
      sender_pubkey: senderPk,
      key_id: KEY_ID,
      chain_key_hex: bytesToHex(CHAIN_KEY_BYTES),
      iteration: 0,
      created_at: CREATED_AT,
      messages: [
        {
          plaintext: JSON.stringify({
            kind: 14,
            content: "Hello from TypeScript sender keys (0)",
          }),
          outer_event: outer0 as unknown as NostrEvent,
        },
        {
          plaintext: JSON.stringify({
            kind: 14,
            content: "Hello from TypeScript sender keys (1)",
          }),
          outer_event: outer1 as unknown as NostrEvent,
        },
      ],
    };

    const outputPath = path.join(
      __dirname,
      "../../test-vectors/ts-one-to-many-vectors.json"
    );
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, JSON.stringify(vectors, null, 2));
    console.log(`Generated OneToMany vectors at ${outputPath}`);
  });

  it("should generate deterministic vectors", () => {
    expect(vectors.key_id).toBe(KEY_ID);
    expect(vectors.chain_key_hex).toBe(bytesToHex(CHAIN_KEY_BYTES));
    expect(vectors.messages.length).toBe(2);
    expect(vectors.messages[0].outer_event.pubkey).toBe(vectors.sender_pubkey);
  });
});

describe("Rust-generated OneToMany vectors", () => {
  it("TypeScript can decrypt Rust OneToMany outer events (out-of-order)", () => {
    const vectorPath = path.join(
      __dirname,
      "../../test-vectors/rust-one-to-many-vectors.json"
    );

    if (!fs.existsSync(vectorPath)) {
      console.log("Rust OneToMany vectors not found, skipping...");
      return;
    }

    const vectors: OneToManyVectors = JSON.parse(fs.readFileSync(vectorPath, "utf-8"));

    const channel = OneToManyChannel.default();
    const receiver = new SenderKeyState(
      vectors.key_id,
      hexToBytes(vectors.chain_key_hex),
      vectors.iteration
    );

    // Deliver second first to validate skip-key caching.
    const m1 = vectors.messages[1];
    const m0 = vectors.messages[0];

    const p1 = channel.parseOuterContent(m1.outer_event.content);
    const p0 = channel.parseOuterContent(m0.outer_event.content);

    expect(p1.decrypt(receiver)).toBe(m1.plaintext);
    expect(p0.decrypt(receiver)).toBe(m0.plaintext);
  });
});

