//! Interop tests for Signal-style sender keys + one-to-many outer payloads.

use nostr::JsonUtil;
use nostr_double_ratchet::{OneToManyChannel, Result, SenderKeyState, MESSAGE_EVENT_KIND};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Deserialize, Serialize)]
struct OneToManyVectors {
    description: String,
    sender_secret_hex: String,
    sender_pubkey: String,
    key_id: u32,
    chain_key_hex: String,
    iteration: u32,
    created_at: u64,
    messages: Vec<OneToManyMessageVector>,
}

#[derive(Debug, Deserialize, Serialize)]
struct OneToManyMessageVector {
    plaintext: String,
    outer_event: serde_json::Value,
}

fn get_test_vectors_path() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent() // crates/
        .unwrap()
        .parent() // rust/
        .unwrap()
        .parent() // repo root
        .unwrap()
        .join("test-vectors")
}

fn hex_to_bytes32(hex_str: &str) -> [u8; 32] {
    let bytes = hex::decode(hex_str).expect("Invalid hex");
    let mut arr = [0u8; 32];
    arr.copy_from_slice(&bytes);
    arr
}

#[test]
fn test_decrypt_typescript_one_to_many_vectors_out_of_order() -> Result<()> {
    let vectors_path = get_test_vectors_path().join("ts-one-to-many-vectors.json");

    if !vectors_path.exists() {
        println!(
            "TypeScript one-to-many vectors not found at {:?}, skipping...",
            vectors_path
        );
        println!("Run `pnpm vitest run tests/OneToManyChannel.interop` in ts/ to generate them.");
        return Ok(());
    }

    let content = fs::read_to_string(&vectors_path).expect("Failed to read vectors");
    let vectors: OneToManyVectors =
        serde_json::from_str(&content).expect("Failed to parse vectors");

    println!("Loaded vectors: {}", vectors.description);
    assert_eq!(vectors.messages.len(), 2);

    let chain_key = hex_to_bytes32(&vectors.chain_key_hex);
    let mut receiver = SenderKeyState::new(vectors.key_id, chain_key, vectors.iteration);
    let channel = OneToManyChannel::default();

    // Deliver message 1 first to validate skipped key cache.
    let m1 = &vectors.messages[1];
    let m0 = &vectors.messages[0];

    let e1: nostr::Event =
        serde_json::from_value(m1.outer_event.clone()).expect("Failed to parse outer event");
    let e0: nostr::Event =
        serde_json::from_value(m0.outer_event.clone()).expect("Failed to parse outer event");

    assert_eq!(e0.kind, nostr::Kind::Custom(MESSAGE_EVENT_KIND as u16));
    assert_eq!(e1.kind, nostr::Kind::Custom(MESSAGE_EVENT_KIND as u16));
    assert!(e0.verify().is_ok());
    assert!(e1.verify().is_ok());
    assert_eq!(e0.pubkey.to_hex(), vectors.sender_pubkey);
    assert_eq!(e1.pubkey.to_hex(), vectors.sender_pubkey);

    let parsed1 = channel.parse_outer_content(&e1.content)?;
    assert_eq!(parsed1.key_id, vectors.key_id);
    let p1 = parsed1.decrypt(&mut receiver)?;
    assert_eq!(p1, m1.plaintext);

    let parsed0 = channel.parse_outer_content(&e0.content)?;
    assert_eq!(parsed0.key_id, vectors.key_id);
    let p0 = parsed0.decrypt(&mut receiver)?;
    assert_eq!(p0, m0.plaintext);

    Ok(())
}

#[test]
fn test_generate_rust_one_to_many_vectors() -> Result<()> {
    let sender_secret_hex = "1111111111111111111111111111111111111111111111111111111111111111";
    let sender_sk = hex_to_bytes32(sender_secret_hex);
    let sender_keys = nostr::Keys::new(nostr::SecretKey::from_slice(&sender_sk)?);
    let sender_pubkey = sender_keys.public_key().to_hex();

    let key_id: u32 = 123;
    let chain_key = [7u8; 32];
    let iteration: u32 = 0;
    let created_at: u64 = 1_700_000_000;

    let mut sender_state = SenderKeyState::new(key_id, chain_key, iteration);
    let channel = OneToManyChannel::default();

    let inner0 =
        serde_json::json!({ "kind": 14, "content": "Hello from Rust sender keys (0)" }).to_string();
    let inner1 =
        serde_json::json!({ "kind": 14, "content": "Hello from Rust sender keys (1)" }).to_string();

    let outer0 = channel.encrypt_to_outer_event(
        &sender_keys,
        &mut sender_state,
        &inner0,
        nostr::Timestamp::from(created_at),
    )?;
    let outer1 = channel.encrypt_to_outer_event(
        &sender_keys,
        &mut sender_state,
        &inner1,
        nostr::Timestamp::from(created_at),
    )?;

    let vectors = OneToManyVectors {
        description: "OneToManyChannel test vectors generated by Rust".to_string(),
        sender_secret_hex: sender_secret_hex.to_string(),
        sender_pubkey,
        key_id,
        chain_key_hex: hex::encode(chain_key),
        iteration,
        created_at,
        messages: vec![
            OneToManyMessageVector {
                plaintext: inner0,
                outer_event: serde_json::from_str(&outer0.as_json()).unwrap(),
            },
            OneToManyMessageVector {
                plaintext: inner1,
                outer_event: serde_json::from_str(&outer1.as_json()).unwrap(),
            },
        ],
    };

    let output_path = get_test_vectors_path().join("rust-one-to-many-vectors.json");
    fs::create_dir_all(output_path.parent().unwrap()).ok();
    fs::write(
        &output_path,
        serde_json::to_string_pretty(&vectors)
            .map_err(|e| nostr_double_ratchet::Error::Storage(e.to_string()))?,
    )
    .map_err(|e| nostr_double_ratchet::Error::Storage(e.to_string()))?;

    println!("Generated Rust one-to-many vectors at {:?}", output_path);

    Ok(())
}
