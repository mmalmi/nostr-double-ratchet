use nostr_double_ratchet::{SharedChannel, SHARED_CHANNEL_KIND, GROUP_INVITE_RUMOR_KIND};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Serialize, Deserialize)]
struct SharedChannelVectors {
    description: String,
    /// Hex-encoded 32-byte secret used for all test cases
    secret_hex: String,
    /// Hex public key derived from the secret
    channel_pubkey: String,
    /// An encrypted event created by TS SharedChannel
    encrypted_event: Option<serde_json::Value>,
    /// The plaintext rumor that was encrypted
    plaintext_rumor: serde_json::Value,
    /// Group metadata event with ["l", groupId] tag
    group_tagged_event: serde_json::Value,
}

fn get_test_vectors_path() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent() // crates/
        .unwrap()
        .parent() // rust/
        .unwrap()
        .parent() // repo root
        .unwrap()
        .join("test-vectors")
}

#[test]
fn test_shared_channel_roundtrip() {
    // Use a deterministic secret
    let secret_hex = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let secret_bytes: [u8; 32] = hex::decode(secret_hex).unwrap().try_into().unwrap();

    let channel = SharedChannel::new(&secret_bytes).unwrap();

    // Verify public key derivation
    let keys = nostr::Keys::new(nostr::SecretKey::from_slice(&secret_bytes).unwrap());
    assert_eq!(channel.public_key(), keys.public_key());

    // Create and decrypt a rumor
    let rumor = serde_json::json!({
        "id": "test-rumor-id",
        "pubkey": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
        "created_at": 1700000000,
        "kind": GROUP_INVITE_RUMOR_KIND,
        "tags": [],
        "content": "{\"inviteUrl\":\"https://iris.to#test\",\"groupId\":\"test-group\"}"
    }).to_string();

    let event = channel.create_event(&rumor).unwrap();

    // Verify event properties
    assert_eq!(event.kind, nostr::Kind::Custom(SHARED_CHANNEL_KIND as u16));
    assert_eq!(event.pubkey, channel.public_key());

    // Verify d tag
    let d_tag = event.tags.iter().find(|t| {
        t.as_slice().first().map(|s| s.as_str()) == Some("d")
    });
    assert!(d_tag.is_some());

    // Decrypt
    let decrypted = channel.decrypt_event(&event).unwrap();
    let original: serde_json::Value = serde_json::from_str(&rumor).unwrap();
    let result: serde_json::Value = serde_json::from_str(&decrypted).unwrap();
    assert_eq!(original, result);
}

#[test]
fn test_generate_rust_shared_channel_vectors() {
    let secret_hex = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let secret_bytes: [u8; 32] = hex::decode(secret_hex).unwrap().try_into().unwrap();

    let channel = SharedChannel::new(&secret_bytes).unwrap();
    let channel_pubkey = channel.public_key().to_hex();

    let rumor = serde_json::json!({
        "id": "interop-test-rumor",
        "pubkey": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
        "created_at": 1700000000,
        "kind": GROUP_INVITE_RUMOR_KIND,
        "tags": [],
        "content": "{\"inviteUrl\":\"https://iris.to#interop\",\"groupId\":\"interop-group\"}"
    });

    let event = channel.create_event(&rumor.to_string()).unwrap();

    // Group tagged event example (what a fan-out message looks like)
    let group_tagged = serde_json::json!({
        "id": "group-msg-id",
        "pubkey": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
        "created_at": 1700000000,
        "kind": 14,
        "tags": [
            ["l", "test-group-id"],
            ["ms", "1700000000000"]
        ],
        "content": "Hello from Rust group!"
    });

    let vectors = SharedChannelVectors {
        description: "SharedChannel test vectors generated by Rust".to_string(),
        secret_hex: secret_hex.to_string(),
        channel_pubkey,
        encrypted_event: Some(serde_json::json!({
            "id": event.id.to_hex(),
            "pubkey": event.pubkey.to_hex(),
            "created_at": event.created_at.as_u64(),
            "kind": event.kind.as_u16(),
            "tags": event.tags.iter().map(|t| t.as_slice().iter().map(|s| s.as_str().to_string()).collect::<Vec<_>>()).collect::<Vec<_>>(),
            "content": event.content,
            "sig": event.sig.to_string(),
        })),
        plaintext_rumor: rumor,
        group_tagged_event: group_tagged,
    };

    let output_path = get_test_vectors_path().join("rust-shared-channel-vectors.json");
    fs::create_dir_all(output_path.parent().unwrap()).ok();
    fs::write(
        &output_path,
        serde_json::to_string_pretty(&vectors).unwrap(),
    ).expect("Failed to write vectors");

    println!("Generated Rust SharedChannel vectors at {:?}", output_path);
}

#[test]
fn test_parse_typescript_shared_channel_vectors() {
    let vectors_path = get_test_vectors_path().join("ts-shared-channel-vectors.json");

    if !vectors_path.exists() {
        println!(
            "TypeScript SharedChannel vectors not found at {:?}, skipping...",
            vectors_path
        );
        println!("Run `pnpm vitest run tests/SharedChannel.interop` in ts/ to generate them.");
        return;
    }

    let content = fs::read_to_string(&vectors_path).expect("Failed to read vectors");
    let vectors: SharedChannelVectors = serde_json::from_str(&content).expect("Failed to parse vectors");

    println!("Loaded SharedChannel vectors: {}", vectors.description);

    // Verify we derive the same pubkey from the same secret
    let secret_bytes: [u8; 32] = hex::decode(&vectors.secret_hex).unwrap().try_into().unwrap();
    let channel = SharedChannel::new(&secret_bytes).unwrap();
    assert_eq!(
        channel.public_key().to_hex(),
        vectors.channel_pubkey,
        "Channel pubkey should match TS-derived pubkey"
    );

    // If TS provided an encrypted event, verify we can decrypt it
    if let Some(ref encrypted) = vectors.encrypted_event {
        let event: nostr::Event = serde_json::from_value(encrypted.clone())
            .expect("Failed to parse TS encrypted event");

        // Verify it's a channel event
        assert!(channel.is_channel_event(&event), "Should recognize as channel event");

        // Decrypt and verify content matches
        let decrypted = channel.decrypt_event(&event).expect("Failed to decrypt TS event");
        let decrypted_val: serde_json::Value = serde_json::from_str(&decrypted).unwrap();
        assert_eq!(
            decrypted_val["pubkey"],
            vectors.plaintext_rumor["pubkey"],
            "Decrypted pubkey should match"
        );
        assert_eq!(
            decrypted_val["kind"],
            vectors.plaintext_rumor["kind"],
            "Decrypted kind should match"
        );
    }

    // Verify group tagged event format
    let tags = vectors.group_tagged_event["tags"].as_array().unwrap();
    let l_tag = tags.iter().find(|t| {
        t.as_array().unwrap().first().unwrap().as_str().unwrap() == "l"
    });
    assert!(l_tag.is_some(), "Group tagged event should have 'l' tag");

    let ms_tag = tags.iter().find(|t| {
        t.as_array().unwrap().first().unwrap().as_str().unwrap() == "ms"
    });
    assert!(ms_tag.is_some(), "Group tagged event should have 'ms' tag");

    println!("Successfully verified TypeScript SharedChannel vectors!");
}

#[test]
fn test_shared_channel_from_group_secret() {
    // Test creating SharedChannel from a group secret (as generated by generate_group_secret)
    let secret = nostr_double_ratchet::group::generate_group_secret();
    let secret_bytes: [u8; 32] = hex::decode(&secret).unwrap().try_into().unwrap();

    let channel1 = SharedChannel::new(&secret_bytes).unwrap();
    let channel2 = SharedChannel::new(&secret_bytes).unwrap();

    // Same secret â†’ same public key
    assert_eq!(channel1.public_key(), channel2.public_key());

    // Channel 1 creates, channel 2 decrypts
    let rumor = serde_json::json!({
        "id": "test",
        "pubkey": "aabb",
        "created_at": 0,
        "kind": GROUP_INVITE_RUMOR_KIND,
        "tags": [],
        "content": "test"
    }).to_string();

    let event = channel1.create_event(&rumor).unwrap();
    let decrypted = channel2.decrypt_event(&event).unwrap();
    let orig: serde_json::Value = serde_json::from_str(&rumor).unwrap();
    let dec: serde_json::Value = serde_json::from_str(&decrypted).unwrap();
    assert_eq!(orig, dec);
}
